# Crypto-Quant Dashboard: Frontend Architecture Blueprint

## 1. Executive Summary
This document outlines the architecture for a high-performance, institutional-grade Crypto Backtesting Dashboard. The goal is to visualize large datasets (ticks, trades, PnL) generated by the Python/Rust backend with minimal latency, providing a "Bloomberg Terminal" experience for quantitative researchers.

## 2. Technology Stack Recommendation

### Core Framework: **Next.js (React)**
*   **Rationale:** Next.js offers the best balance of Server-Side Rendering (SSR) for initial load performance and Client-Side Rendering (CSR) for interactive dashboards. Its file-based routing and API routes simplify the integration with the backend.
*   **Language:** TypeScript (Strict Mode) is mandatory for type safety across financial data structures.

### State Management: **Zustand + TanStack Query**
*   **Zustand:** For global UI state (e.g., sidebar toggle, theme, selected strategy). Lightweight and performant compared to Redux.
*   **TanStack Query:** For server state (fetching backtest results, caching configuration lists). It handles loading states, caching, and re-fetching out of the box.

### Charting Library: **TradingView Lightweight Charts**
*   **Rationale:** This is the critical choice for performance. Unlike D3.js or Recharts which manipulate the DOM for every element (slow for 10k+ points), Lightweight Charts uses HTML5 Canvas. It is designed specifically for financial time-series data and supports zooming/panning over millions of data points without lag.
*   **Alternatives Considered:**
    *   *Highcharts Stock:* Excellent but requires a paid license for commercial use.
    *   *Plotly.js:* Too heavy for real-time updates of high-frequency data.
    *   *D3.js:* Too low-level, requires building financial primitives from scratch.

### UI Component Library: **Shadcn/ui (based on Radix Primitives)**
*   **Rationale:** Provides accessible, unstyled components that we can fully customize to match the "Dark Mode" financial aesthetic. It fits perfectly with Tailwind CSS.

## 3. UI/UX Design Concept

### Theme & Layout
*   **Style:** "Cyberpunk / Institutional Dark Mode". High contrast, monospaced fonts for numbers (`JetBrains Mono` or `Roboto Mono`).
*   **Color Palette:**
    *   **Background:** `#0d1117` (Deep Blue/Black)
    *   **Surface:** `#161b22` (Panel Background)
    *   **Bullish (Up):** `#26a69a` (Teal/Green)
    *   **Bearish (Down):** `#ef5350` (Red)
    *   **Funding (Fee):** `#ab47bc` (Purple)
    *   **Accent/Primary:** `#2962ff` (Blue)
    *   **Text (Primary):** `#e6e6e6`
    *   **Text (Muted):** `#8b949e`

### Wireframe Areas

1.  **Sidebar (Left - 250px):**
    *   **Strategy Selector:** Dropdown to choose the Python strategy class.
    *   **Configuration Form:** Dynamic form based on strategy parameters (e.g., `Lookback Period`, `RSI Threshold`).
    *   **Symbol & Timeframe:** `BTC/USDT`, `1h`, `15m`.
    *   **Action Buttons:** "Run Backtest", "Optimize".

2.  **Main Charting Area (Center - Flex Grow):**
    *   **Primary Chart:** Candlesticks (OHLCV) + Indicators (SMA, EMA, Bollinger Bands).
    *   **Overlays:**
        *   **Buy/Sell Markers:** Arrows pointing up/down at execution price.
        *   **Positions:** Dashed lines extending from entry price to exit.
        *   **Stop Loss / Take Profit:** Colored horizontal lines (Red/Green) indicating active orders.

3.  **Analytics & Logs Panel (Bottom - Collapsible, 300px height):**
    *   **Tabs:** `Trades`, `Logs`, `Metrics`, `Errors`.
    *   **Trades Table:** Virtualized list (TanStack Virtual) of all executions with columns: `Time`, `Side`, `Price`, `Size`, `Fee`, `Realized PnL`.
    *   **Metrics Summary:** Cards showing `Total PnL`, `Sharpe Ratio`, `Max Drawdown`, `Win Rate`.

## 4. Features & Components

### A. Strategy Configuration Panel
*   **Dynamic Inputs:** The backend should expose a JSON Schema for the selected strategy's parameters. The frontend generates the form (sliders for percentages, inputs for integers).
*   **Validation:** Client-side validation before submission.

### B. Analytics Dashboard (Metrics)
*   **Equity Curve:** A dedicated line chart showing portfolio value over time.
*   **Drawdown Chart:** An area chart below the Equity Curve showing percentage decline from peak.
*   **Key Metrics Cards:**
    *   *Sharpe Ratio:* Risk-adjusted return.
    *   *Sortino Ratio:* Downside risk-adjusted return.
    *   *Max Drawdown (MDD):* Worst peak-to-trough decline.
    *   *Profit Factor:* Gross Profit / Gross Loss.

### C. Trade Inspector
*   **Interaction:** Clicking a trade marker on the main chart highlights the corresponding row in the Trades Table (and vice-versa).
*   **Details:** A modal or side-panel showing execution details:
    *   *Slippage:* Expected vs. Executed Price.
    *   *Latency:* Time from Signal to Fill.
    *   *Fees:* Breakdown of Maker/Taker fees.

## 5. Data Transmission & Backend Integration

### Hybrid Approach: REST + WebSockets

1.  **REST API (FastAPI):**
    *   `GET /strategies`: List available strategy classes.
    *   `GET /config/{strategy_id}`: Get parameter schema.
    *   `POST /backtest/start`: Initiate a backtest job (returns a `job_id`).
    *   `GET /history/{symbol}`: Fetch historical OHLCV for initial chart load (can be large, use pagination or compression).

2.  **WebSockets (FastAPI / Starlette):**
    *   **Endpoint:** `/ws/backtest/{job_id}`
    *   **Purpose:** Real-time streaming of backtest progress.
    *   **Protocol:**
        *   **Progress:** `{ "type": "progress", "percent": 45, "current_date": "2023-01-01..." }`
        *   **New Candle:** `{ "type": "candle", "open": ..., "close": ... }` (Simulating live data)
        *   **Trade Event:** `{ "type": "trade", "side": "buy", "price": 50000, ... }`
        *   **Log:** `{ "type": "log", "level": "INFO", "message": "Signal triggered..." }`

### Data Optimization
*   **Protobuf / MsgPack:** For extremely large datasets (millions of candles), use binary formats instead of JSON to reduce payload size and parsing time.
*   **Sampling:** For the "Equity Curve" chart, downsample data if the backtest spans years (e.g., 1 point per hour instead of every tick) to keep the UI responsive.

## 6. Security & Performance Considerations
*   **Authentication:** JWT (JSON Web Tokens) for access control.
*   **Sanitization:** Input validation for all strategy parameters to prevent code injection.
*   **Virtualization:** Use `react-window` or `tanstack-virtual` for the Trades Table to render only visible rows.
